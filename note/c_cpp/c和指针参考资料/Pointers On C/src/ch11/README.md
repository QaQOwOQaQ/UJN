# 第十一章：动态内存分配

非常常用且重要！！！

## 本章总结及注意点

![0](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227155242.png)

![1](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201226115416.png)

---

## 部分课后习题解答

### 11.10 问题

1. 取决于系统。可以自己手动声明试一下。

2. 没理解是啥意思。参考答案：可能有两种解释。请求较小的块可能会允许分配更多的内存，因为最后一次分配后剩余的内存量将更小。这将使较小请求的总数变大。不过，更有可能的是较小的请求越小：这是由于malloc附加到内存的额外空间的开销，以便跟踪每个分配的块的大小。

3. 最长行长度啊。或者可以分块传输，加上偏移量，不知道可不可。

4. 优点：函数返回时堆栈中申请的空间将被自动释放，不会造成内存泄露。缺点：无法将要返回的数据存在函数内部申请的局部堆栈空间。

5. 错了不知道多少...差不多都找出来错误了，详情直接见参考答案吧：

    ![2](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227152328.png)

6. 当然可以。动态内存分配来的空间在堆上，而不在栈上。堆上能申请到的空间要大很多很多，差不多 `1G`，在 `4G` 内存下。而栈上的简直少的可怜，貌似 `1M`？曾经有个面试题还考过能不能申请一个 `int[1024][1024]` 的局部数组？考察的就是函数栈空间很少造成申请失败。使用标量数据的动态分配只有在其被分配的值大于指针的大小时才有好处，显然对于 4 字节的整数，采用动态分配没有好处，因为必须有指针变量跟踪它所需要的空间和整数本身一样多。

7. 内存泄露。

### 11.11 编程练习

1. 相较于 `malloc()`，`calloc()` 申请完空间会将其初始化为 0。见 `demo01.c`。

2. 几个要点：通过 `scanf()` 的返回值来判断 `EOF` 即可。增减空间时要把首元素的空间留着，要存储元素值的个数。最后由于已经知道了元素个数，调用 `relloc()` 函数将后续没用到的空间再缩小回来即可。全程就用 `relloc()` 的话不需要 `free()`。见 `demo02.c`。

3. 按字符读取字符串，写进缓冲区，动态判断读取字符的个数和缓冲区大小，若放不下则选择增容，`relloc()` 即可。最后由于记录了字符串个数，则直接 `malloc()` 申请一块刚好的内存将其放入进去即可。注意，`'\0'` 也要占一个空间！见 `demo03.c`。

4. 单链表。建议直接去学习 `ch12`。在这不写了。还有建议 `ch11、12、13` 这三章有关于内存、指针的一起学习。

### 随笔

`P222`, `relloc()` 函数原型明显出错。返回值应该是 `void *`，而不仅仅是 `void`。正确的函数原型：`void *realloc(void *ptr, size_t size)`。

### 疑问

1. 我的编译器没有 `alloca()`。

2. `P230` 变体记录的动态内存分配版本蛮秀的。 `P231` 变体记录的销毁优化部分没咋看懂，非这样写不被人淦？
