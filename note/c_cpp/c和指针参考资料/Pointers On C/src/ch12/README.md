# 第十二章：使用结构和指针

结构和指针创造了无数伟大的数据结构！

## 本章总结及注意点

![0](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227161012.png)

![1](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201228130256.png)

---

## 部分课后习题解答

### 12.7 问题

1. 当然可以。把有 `current` 的地方全部换成 `*list`，就行了。虽然少用了一个变量，但是增加了思维难度，不好理解，没啥大用途。

2. 我觉得很好用啊，`dummy->next = head;` 这样不知道简化了多少代码和思维量。然而书中确实给出了最优的解法，但是 `root` 节点不就是 `dummy` 节点吗？真的不清楚纠结这两者区别有啥用。虽说记录变化的 `link` 指针的思想确实很重要。见参考答案：

    ![2](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227162639.png)

3. 不改，在相同值的前面。改了，在最后面。

4. 我还以为要赋值为一个无效值...还是太年轻了啊...局部初始化、分离化设计、结构标签的不完整声明...tql！！！见参考答案：

    ![2](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227163032.png)

5. 这是直接申请一个空间，且没有 `free()`。当每次有重复值的时候，就会内存泄露一个空间！

6. 当然可以，$O(n^2)$ 扫一遍找到一个最大、最小值，插入一个新有序链表即可。

7. 您这是把 `trie` 树都掏出来了啊。总结的模板：[**[字典树+模板] Trie树模板**](https://blog.csdn.net/yl_puyu/article/details/109214829)。参考答案：

    ![3](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227164028.png)

### 12.8 编程练习

1. 链表结构。可以记录链表中任意一点到末尾的节点数量。见 `demo01.c`。

2. 没必要写这题。无序链表全部扫描完毕，有序链表如果扫描位置大于当前数，则不需要再扫描后面的了，直接返回即可。

3. 参考答案：这使得函数更加复杂，主要是因为根指针不再是操作方法与节点指针相同。见 `demo03.c`。

4. 经典问题了。参考：[**[E链表] lc206. 反转链表(反转链表+模板题)**](https://blog.csdn.net/yl_puyu/article/details/109188915)。我的这篇博文写的很细致，三种方法一一说明了！很建议学习！

5. 不想写了。

    ![4](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227165405.png)
    ![5](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227165533.png)

6. 同上。参考答案：注意这个程序中的间接链:`this->bwd->fwd` 和 `this->fwd->bwd`: `if` 这两种表达方式都已经用过不止一次了，创造可能会更好保存值的临时变量。见 `demo03.c`。

7. 动态内存分配的怎么说呢，用的太少了。一般直接拿数组模拟。[**[字典树+模板] Trie树模板**](https://blog.csdn.net/yl_puyu/article/details/109214829)。

    **参考答案：**
    两个列表中的节点在结构上不同，这一事实排除了使用单个插入函数的可能性对于列表;这很不幸，因为每种情况都需要相同的逻辑的声明如果任何其他源文件需要下面的解决方案，那么它们应该在包含文件中。见 `demo04.c`。

### 随笔

没啥好说的，链表边界情况很多。现在要么在力扣上拿结构体写，要么数组模拟单链表，不过结构体每次 `malloc()` 是很耗时间的。每次只申请一个 `Node` 节点，貌似听哪位佬说过，申请一个大空间和申请一个小空间操作系统所用的时间相差不大，即申请次数越多，所耗时间越多。

链表也是基础了，双链表用的少。后续有邻接表在图论题目中经常用到！

本章可以理解为语法的应用，尤其是结构和指针的联合使用创造出了很厉害的数据结构，这些前面都已经接触过了，所以我动手写的很少，**初学者也不建议在这写，可以简单的写一写，然后数据结构直接找本书专项练习，大量写代码。**

### 疑问

1. 处理单链表头插时头结点改变的方法很秀，很细节。只需要保存需要改变的 `link` 指针就行了。一般在算法题中，尤其是力扣，遇见头结点会改变的链表，都会申请一个虚拟头结点来帮助处理，简化很多边界判断。

2. 双链表改变指针指向的时候一定**是要注意顺序的。**

3. `P249-P252` 整个就在做一件事情：**乱秀！**。采用一系列的代码优化方法，硬是提取公共无关项、整合 `if-else` 等等，写的秀是秀，但是看着都费劲啊...
