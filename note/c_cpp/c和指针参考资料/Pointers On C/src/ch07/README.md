# 第七章：函数

函数式编程，面向过程。

## 本章总结及注意点

![0](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227190744.png)

![1](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227174606.png)

![2](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201220142925.png)

---

## 部分课后习题解答

### 7.10 问题

1. 可在其内部打印一句话，表示它已被调用。

2. 我认为，没有半毛钱优点...严格的规范，学起来才简单。

   **参考答案**：它的一个优点是它允许您变得懒惰；可以编写的代码更少。其他的后果，比如能够用错误的参数数或类型调用函数，是所有缺点。

3. 最终值将转换为 `A` 类型。

4. `return ;` 可以，但是不能 `return 表达式;` 编译器将报错。

5. 返回值将被按照 `int` 类型进行解释。

6. 将被解释为形参类型，而不是实际类型。

7. 见 `demo04.c`。该函数假定了传入进来的数组大小是 10 个元素，如果数组元素大于 10 个，则会忽略后面的元素，如果数组元素小于 10 个，则出现越界访问。事实上就是数组名做了参数，即退化为指针。**且由于 `for` 循环固定死了为 10 次，这是问题的本质所在。**

8. 都要有终止条件，且不断逼近终止条件。

9. 在多个源文件中使用#include比复制原型更容易。原型本身只有一个副本。在定义函数的文件中包含原型可确保它们匹配。

10. 见 `demo05.c`。

    ![3](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201220161621.png)

### 7.11 编程练习

1. 简单的递归，见 `demo06.c`。

2. 经典的 `gcd` 函数，一行搞定，且代码时间复杂度为 $O(logn)$。见 `demo07.c`。

3. 实际上就是实现 `atoi()` 函数。见 `demo08.c`。

4. 见 `demo09.c`。简单的可变参函数。

5. 该来的还是来了，实现一个简单的 `printf` 函数。主要就是格式化字符串中的 `%`，如果不为 `%` 后面的一个字符，则将该字符直接打印输出。找到 `%` 后，查看其下一个字母是什么，分别针对处理即可。注意处理 `%` 下一个为 `\0` 的情况，以及 `%s` 这个情况。见 `demo10.c`。

6. 个人感觉可等价看作 16312=16*1000 + 3*100 + 12 即可，故任何一个数字都可以这样分解，在进行组合即可。但是看着简单写着好麻烦...参考答案，见 `demo11.c`。

### 随笔

函数确实经常在用着。但是关于函数声明(函数原型)、`C`语言不支持重载函数、可变参函数实现等些许细节问题，自己在以往的学习过程中并没有深究探索。还是知道的太少了。

### 疑问

本章用的很多，但是细节知道的却很少，如：当函数定义在 `main` 函数下面，且之前未声明就在 `main` 函数直接调用会发生什么？编译器怎么处理？可变参函数编程的应用？`printf` 函数的具体实现。等等，函数确实是 `C` 语言项目的骨架。

1. [C语言编译出现conflicting types for错误？](https://www.zhihu.com/question/41722867)

2. [现代编译器是如何实现自定义函数在main()函数之后实现的呢?](https://www.zhihu.com/question/53481208/answer/135161023)

3. 可变参函数编程，`printf` 函数实现原理。

4. **最后一个编程题真滴 np!**
