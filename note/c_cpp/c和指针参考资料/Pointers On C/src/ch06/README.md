# 第六章：指针

`C` 语言的精华及难点。

## 本章总结及注意点

![0](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227174009.png)

![1](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201217205033.png)

![2](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201217205213.png)

---

## 部分课后习题解答

### 6.17 问题

1. 通过中间编译器，编译器来判断，并创建合适的指令，机器来执行这些指令即可。

2. 内存无法提前预知，此操作意义非常之小，书上已经给了详尽说明。

3. 该值为一个整数，且没有取地址这个符号，则编译器就不生成对应指令，故无法将其解释为地址。

4. 书上讲了。因编译器而异，可能是 0，也能直接崩溃。一定要避免对空指针解引用。

5. 我觉得是没有，但是很明显，考虑的过于片面...

    **参考答案：** 即使 `offset` 的值与下一个表达式中的文本值相同，计算第一个表达式也要花费更多的时间，因为要将 `offset` **缩放到整数必须在运行时完成**。这是因为变量可能包含任何值，而编译器无法提前知道实际值可能是什么。另一方面在编译时，字面值 3 可以通过在编译时乘以它来缩放为一个整数，结果这个乘法的值在运行时被简单地加到 `p` 上。换句话说，第二个表达式可以通过简单地将 `12` 加到 `p`（在一台有四个字节整数的机器上）来实现；**无需运行时需要乘法。**。

    总结来看就是第一个操作，在运行期间才能完成，而针对字面值常量的话，在编译期间就已经确定了，故在编译期间就能完成。其实就是指针偏移。

6. 两个错误。前置 `++` 导致数组第一个元素并没有被清 0，且最后会越过数组有边界并解引用将该块空间清 0。**还有一个内存连续导致的经典死循环问题，我没有考虑到**...详见参考答案：

    ![3](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201227174146.png)

7. 看着头疼...建议直接去刷牛客单选。参考答案：

    ![4](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201217211816.png)

### 6.18 编程练习

1. $O(n^2)$ 暴力匹配一遍就行了。其实哈希应该是最香的。题目提示说 `strpbrk` 作为库函数，功能和题目描述的很相似。`C` 库函数 `char *strpbrk(const char *str1, const char *str2)` 检索字符串 `str1` 中第一个匹配字符串 `str2` 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 `str1` 中的字符，当被检验字符在字符串 `str2` 中也包含时，则停止检验，并返回该字符位置。`char *strpbrk(const char *str1, const char *str2)`其中，`str1` -- 要被检索的 `C` 字符串。`str2` -- 该字符串包含了要在 `str1` 中进行匹配的字符列表。该函数返回 `str1` 中第一个匹配字符串 `str2` 中字符的字符数，如果未找到字符则返回 `NULL`。见 `demo02.c` 包含了函数实现及库函数展示。求两个字符串第一个匹配的字符。

2. 找到给定子串并删除，字符串的模式匹配都出来了...当让这里只写了个暴力匹配。在这出现了一个 `nt` 问题，`char *p = "ABC"` 这样 `p` 指向了常量字符串，则 `*p++ = *s++` 这种修改常量空间的操作是会 `SE` 的。见 `demo03.c`。

3. 逆置一个字符串。不论是数组还是指针都可以完成该操作。注意 `while(*t++ != '\0')` 会使 `t` 走到 `'\0'` 的后一位去...越界了。简单修改一下就可以了。见 `demo04.c`。

4. 这是埃筛啊。详见：[[数论+模板] 三大质数筛法(模板)
](https://blog.csdn.net/yl_puyu/article/details/109405020)。见 `demo05.c`。让拿字符数组不知道是啥理解。

5. 没看懂是啥意思。第五章编程练习第 4 题确实写过一个位数组，但是埃筛重点思想在于算法，拿这个来实现也没啥意义，甚至最重要的是欧筛，而不是埃筛。只存奇数、不存偶数，能让多筛出来一倍的质数。

    **参考答案**：这个程序也只计算奇数，所以位数组的大小是它的一半否则就是。请注意，在 `SIZE` 声明中使用 `CHAR_BIT` 来获得位数每个字符。在此声明中添加一个可确保在中出现足够的字符即使所需的位数不能被字符位平均整除。首字母将整个数组设置为 `TRUE` 的循环本可以一点一点地完成，但逐字节执行会更快字节。如果数组声明为整数，则速度会更快，但是当调用位数组函数必须将参数强制转换为字符指针。

    没看懂说的是些啥...

    没读懂题...

6. 埃筛效率还行，筛 `10^7` 以内的数字应该都可以 1 秒出解。可自行拿 `demo05.c` 的埃筛源代码试试。每千个数的素数在减少，但速度越来越慢。这种趋势继续保持至少10亿。其实能够通过算术基本定理能够考虑到，素数最后之间的间隔将会越来越大（个人猜测hh）。

### 随笔

最近深感，写这个文档很占用时间。确实学到了很多知识，但是性价比很低，毕竟 `C` 语言来来回回也都看了几遍了，虽说很零散的看，但对于这本入门书的前半段来讲，还是 `hold` 住的。故，以后尽量精简一点...

### 疑问

本章还是很基础且重点的。详细介绍了指针的基本使用及坑点，前置 `++` 和 后缀 `++` 在指针中的基本使用也是经常被弄混淆的一点。这些确实都是基础知识，可能以后也没人这样花里胡哨的写，但并不代表它不重要。

1. C语言编译错误：`Variably modified array at file scope`。引自：[C语言编译错误：Variably modified array at file scope](http://xsk.tehon.org/den/index.php/category/tech/c-variably-modified-array-at-file-scope.html)

    ![5](https://raw.githubusercontent.com/Y-puyu/picture/main/images/20201218135331.png)
2. 常量指针不能修改其值，否则运行时 `SE`，例：`char *p = "sasasa";`。 `p` 不允许被修改。
