# 第十七章（2） 条件触发和边缘触发

## 一、条件触发（Level Trigger）
只要输入缓冲有数据，就一直触发。
其原理是，当输入缓冲中第一次有数据时，会触发监视事件，此时服务器可以选择处理或者不处理该事件，如果没处理或者只是处理的一部分（此时输入缓冲中还有未处理的数据），就会继续注册该事件。这样当下一次 epoll_wait 的时候，该事件仍会触发。大概是监视到输入缓冲中存有数据，它不管你这数据是之前没处理的，还是刚刚到的，都认为是自从注册之后来的。因此，再一次触发该事件。

## 二、边缘触发（Edge Trigger）
只会触发一次，也就是说仅注册该事件一次。
epoll 和 select 都是默认条件触发的。
通过将 event 设置为 EPOLLET 即可设置为边缘触发。

## 三、边缘触发必知的两点
1. 通过 error 变量验证错误原因
2. 为了完成非阻塞（No-blocking）I/O，更改套接字特性。

### 1. error 变量
Linux 套接字相关函数一般通过 -1 通知发生了错误。虽然知道发生了错误，但仅凭这些内容**无法得知产生发生错误的原因**。因此，为了在发生错误的时候**提供额外的信息**，Linux 声明了如下全局变量：
`int errno;`
为了访问该变量，需要引入 `<error.h>` 头文件，此头文件有上述变量的 `extern` 声明，保存在 `errno` 变量中的值都不同。

> read 函数发现输入缓冲中没有数据可读时返回 -1，同时在 errno 中保存 EAGAIN 常量

### 2. 更改套接字特性
``` c++
#include <fcntl.h>
int fcntl(int fields, int cmd, ...);
/*
成功时返回 cmd 参数相关值，失败时返回 -1
filedes : 属性更改目标的文件描述符
cmd : 表示函数调用目的
*/
```
从上述声明可以看出 fcntl 有可变参数的形式。如果向第二个参数传递 F_GETFL ，可以获得第一个参数所指的文件描述符属性（int 型）。反之，如果传递 F_SETFL ，可以更改文件描述符属性。若希望将文件（套接字）改为非阻塞模式，需要如下 2 条语句。
``` c++
ing flag = fcntl(fd, F_GETFL, 0);       // 保存旧树形
fcntl(fd, F_SETFL, flag | O_NONBLOCK);  // 设置新属性
```
通过第一条语句，获取之前设置的属性信息，通过第二条语句在此基础上添加非阻塞 O_NONBLOCK 标志。调用 read/write 函数时，无论是否存在数据，都会形成非阻塞文件（套接字）。fcntl 函数的适用范围很广。

### 3. 插叙：read 返回值
当返回值大于0时：实际读到的字节数

返回值=0：
如果读的文件：说明文件读完了
如果从管道或socket中读：说明对端关闭了

返回值为-1：说明发生了异常，根据errno的值进一步判断
errno == EINTR 被信号中断
errno == EAGAIN(EWOULDBLOCK) 非阻塞方式读，并且没有数据
其他值 代表 出现错误，可以获得返回值，然后利用strerror(ret)去打印错误信息

### 4. 插叙：阻塞/非阻塞IO
阻塞IO: 必须做完IO操作才会返回。
非阻塞IO：操作成功与否，都会返回，需要通过其他方式判断具体操作是否成功。(效率更高)

### 5. 这两点的意义
通过 errno 确认错误的原因是：边缘触发方式中，接收数据仅注册一次该事件。
因为这种特点，一旦发生输入相关事件时，就**应该读取输入缓冲中的全部数据**。因此需要**验证输入缓冲是否为空**。

> read 函数返回 -1，变量 errno 中的值变成 EAGAIN 时，说明没有数据可读。这里的 read 返回 0 表示对方关闭连接。

既然如此，为什么要将套接字变成非阻塞模式？边缘触发条件下，以阻塞方式工作的 read & write 函数有可能**引起服务端的长时间停顿**。因此，边缘触发方式中一定要采用非阻塞 read & write 函数。

## 四、条件触发和边缘触发孰优孰劣
只需要记住这一条：
> **边缘触发**可以分离接受数据和处理数据的时间点

因为未处理的数据并不会丢掉！它仍然存放在输入缓冲中。

那你可能会问，条件触发也不会丢掉数据啊？
是的，但是条件触发中，如果你不处理输入的数据，它此后会一直注册并报告监视事件，这是有很多额外开销的。

因此，即使输入缓冲收到数据，服务器端也能决定读取和处理这些数据的时间点，这样就给服务器端的实现带来很大灵活性。
