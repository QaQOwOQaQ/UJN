# Csapp Link

##  ::English

separate compliation：分离编译

mangling：重整



## :: Tool

GNU READELF：查看目标文件内容的很方便的工具。

## 0x00 introduce



### 1. 链接的执行阶段

1. compile time
2. load time
3. run time

### 2. **why** learn link

1. 理解链接器将帮助你构造大型程序
2. 理解链接器将帮助你避免一些危险的编程错误。
3. 理解链接器将帮助你理解语言的作用域规则是如何实现的。
4. 理解链接将帮助你理解其他重要的系统概念。（加载和运行程序，虚拟内存，分页，内存映射）
5. 理解链接将使你能够利用共享库。





## 0x01 compiler driver



compiler dirver：编译器驱动程序

它代表用户在需要的时候调用：

1. cpp
2. cc1
3. as
4. ld

可以使用 -v 选项查看这个过程

当我们在 Linux 命令行输入：```./proc```

shell 调用操作系统中一个叫做**加载器**的函数，它将可执行文件 proc 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。



## 0x02 static link



Relocaable object file: 由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。

为了构造 executable file，linker 必须完成两个主要任务：

1. Symbol resolution（符号解析）：符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
2. relocation（重定位）。



Symbol（符号）：目标文件定义和引用符号，每个符号对应于一个函数，一个局部变量或一个静态变量（即C语言任何非 static 属性声明的变量）。

Compiler and Assembly generate code and data section start at address 0, linker connect every symbol define with one memory address, so can relocate those sections, and then modify all the symbol define, make them point the address. Linker use the detailed instructions of relocation entry(重定位条目) which generated by assembly to execute those relocation with no check.



## 0x03 object file



object file（目标文件） types:

1. relocatable object file：在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
2. executable object file
3. Share object file（共享目标文件）: 一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

Compiler and Assembly generate relocatable object file.  Linker generate executable  object file.

Technically talking, a object module(目标模块) is a byte sequence,  and a object file is a object module which storage in disk as a type of file.

目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。

1. Unix: a.out
2. Windows: PE(Portable Executable)(可移植可执行)
3. MacOS-X: Mach-O 
4. Modern x86-64 and Unix: ELF(Executable and Linkable Format)(可执行可链接格式)



## 0x04 relocatable object file



典型的ELF可重定位目标文件

![IMG](https://s1.328888.xyz/2022/09/28/spfaF.png)



ELF contains:   ELF header，Sections，Section header table(节头部表)。

(1) ELF header：

1. 以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的**字的大小**和**字节顺序。**
2. 剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包含：
   * ELF 头的大小
   * 目标文件的类型（可重定位、可执行或者共享）
   * 机器类型（x86-64）
   * 节头部表的文件偏移
   * 节头部表中条目的大小和数量

(2) Section headere table: 不同 Section 的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目（entry）。

(3) Section:

1. .text：已编译程序的**机器代码。**
2. .rodata：只读数据。
3. .data：已初始化的全局和静态 C 变量。（局部变量在栈中，既不出现在 .data中，也不出现在 .bss汇总）
4. .bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量（默认初始化）。在目标文件中**这个节不占用实际的空间，它仅仅是一个占位符。** 目标文件中区分 .bss 和 .data 是为了**空间效率**：在目标文件中，未初始化变量不需要占用任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化为0。
5. .symtab；符号表。存放在程序中**引用**和**定义**的函数和全局变量的信息。（不包含局部变量的条目）。
6. .rel.text：relocation。一个 .text 节总位置的列表。当 Linker 把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的**指令**都需要修改。
7. .rel.data：被模块定义或引用的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的值是一个全局变量地址或者外部定义的函数的**地址**，都需要被修改。
8. .debug：调试符号表。只有使用 -g 选项时才会得到这张表。
9. .line：原始 C 源程序中的行好和 .text 节 中机器指令之间的**映射**。只有使用 -g 选项时才会得到这张表。
10. .strtab：字符串表。其内容包含 .symbol 和 .debug节中的符号表，已经节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。

为什么未初始化的数据成为  .bss

> 起始于 IMB 704 汇编语言（大约在1957年） Block Storage Start(块存储开始)指令的首字母缩写。并沿用至今。
>
> 你可以这样理解并区分于 .data：Better Save Space（更好的节省空间）的缩写。





## 0x05 symbol and symbol table

​			 	

每个 relocatable object module m 都有一个符号表，它包含 m 定义和引用的符号的信息。在 Linker 的上下文中，有三种不同的符号：

1. m 定义的并且能被其他 module 引用的全局符号。
2. 其他 module 定义并被模块 m 引用的全局符号，
3. 只被 m 定义和引用的局部符号。



符号表是由 Assembly 构造的，使用 Compiler 输出到汇编语言 .s 文件中的符号。

.symtab 节的内容是一个数组，数组的元素是一个符号条目：

``` c
typedef struct {
    int name;
    char type: 4,
    	binding: 4;
    char reserved;
    short section;
    long value;
    long size;
} Elf_64_Symbol;
```

> name：是字符串表中的字节串，指向符号的以 null 结尾的字符串名字。
>
> section（base_address）：到节头部表的索引，指明被分配到那个节。
>
> value（offset_address）：是符号的地址。对于可重定位的 module 来说，value 是距定义目标的节的其实地址的 offset。
>
> size：是目标的大小（byte）。
>
> type：data or function。
>
> binding：static or global
>
> 有三个特殊的**伪节**，它们在节头部表中是没有条目的（只有可重定位目标模块才有）：
>
> 1. ABS：不应该被重定位的符号。
> 2. UNDEF：未定义的符号，也就是在本目标模块中引用，但是在其它地方定义的符号。
> 3. COMMON：还未被分配位置的未初始化的数据目标。对于 common u符号，value 字段给出**对其要求**。
>
> common 和 .bss 的区别很细微，现代的 GCC 根据以下规则分配符号：
>
> 1. Common: 未初始化的全局变量
> 2. .bss：未初始化的静态变量，及其初始化为0的全局变量和静态变量







## 0x06 symbol parse



### 1.链接器解析符号引用的方法

链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表的一个确定的符号定义关联起来。

对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保他们拥有唯一的名字。

不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或者函数名）时，会假设该符号是在其它某个模块中定义的，升成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。

### 2.c++ 和 java 中的**重整**和**恢复**

C++ 和 Java 都允许重载方法，这些方法在源代码中有相同名字，却有着不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？

因此编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。

幸运的事，C++ 和 Java使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟上原始名字组成的。例如：类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上‘__’（下划线），加上被重整的雷鸣，再加上每个参数的单字母编码。比如：Foo::bar(int, long) 被编码为 bar\_3fooil。

重整全局变量和模版名字的策略是相似的。

例如 C++程序 ：

``` c++
#include <iostream>

using namespace std;

int get(int a, int b)
{
	return a + b;
}

int get(int a, int b, int c)
{
	return a + b + c;
}

int main()
{
	int a = 1, b = 2, c = 3;
	int sum1, sum2;
	sum1 = get(a, b, c);
	sum2 = get(a, b);
	cout << "sum1: " << sum1 << endl;
	cout << "sum2: " << sum2 << endl;
	return 0;
}
```

执行命令：

`readelf mangling.o --syms`

得到如下符号表：

``` shell
Symbol table '.symtab' contains 30 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS mangling.cpp
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .bss
     5: 0000000000000000     1 OBJECT  LOCAL  DEFAULT    4 _ZStL8__ioinit
     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d
     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata
     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d
    10: 00000000000000fc    96 FUNC    LOCAL  DEFAULT    1 _Z41__static_ini[...]
    11: 000000000000015c    28 FUNC    LOCAL  DEFAULT    1 _GLOBAL__sub_I__[...]
    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 .init_array
    13: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    6 $d
    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 .note.GNU-stack
    15: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT   10 $d
    16: 0000000000000000     0 SECTION LOCAL  DEFAULT   10 .eh_frame
    17: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 .comment
    18: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 _Z3getii
    19: 0000000000000020    44 FUNC    GLOBAL DEFAULT    1 _Z3getiii
    20: 000000000000004c   176 FUNC    GLOBAL DEFAULT    1 main
    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4cout
    22: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZStlsISt11char_[...]
    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEi
    24: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4endlIcSt11c[...]
    25: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEPFRSoS_E
    26: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]
    27: 0000000000000000     0 NOTYPE  GLOBAL HIDDEN   UND __dso_handle
    28: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]
    29: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND __cxa_atexit
```

可以观察到，两个 get 函数分别被标识为：`_Z3getii` 和 `_Z3getiii`



### 3. Linux 处理多重定义的符号

强符号：函数和已初始化的全局变量

弱符号：未初始化的全局变量

Linux 处理多重定义的符号名的三个规则：

1. 不允许多个同名的强符号。
2. 如果有一个强符号和多个弱符号同名，选择强符号。
3. 如果有多个弱符号同名，任意选择一个。

### 4. 静态库

#### 4.1 为什么要引入静态库？

如果不引入静态库的话，试想一下编译器开发人员会使用什么方法来向用户提供这些函数。

> 编译器代劳！

一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。对于那些提供了一小部分标准函数的语言（例如 Pascal）是可以的，但是对于 C 这种标准定义了大量的标准函数是不可以的。因为每次添加、修改或删除一个标准库函数时，就需要一个新的编译器版本。然而，对于应用程序猿而言，这种方法是非常方便的，因为标准函数将总是可用（只需要你编译器开发人员搞定就行了，管我什么事 - -



> 所有函数对应一个可重定位目标模块！

另一种方法是将所有的 C 函数都放在一个单独的可重定位目标模块中（比如说 libc.a），应用程序猿可以把这个模块连接到他们的可执行文件中：

`gcc main.c /usr/lib/libc.o`

IOS C99 定义的 C库：libc.a; 数学函数库：libm.a

通过把函数放在目标模块中，可以把编译器的实现与标准函数的实现分离开来。但是，现在每个可执行文件都包含着一份标准函数集合的副本（除非你不链接它，但这怎么可能呢？），这是对**磁盘的极度浪费**！在一个典型的系统中，libc.a 大约是 5MB，llib.a 大约是 2MB）。另外，每个运行的程序都将它的这些函数的副本放在内存中，这是**对内存的极大浪费**。此外，只要标准库修改了一个小小的地方，无论多么小，你都要重新编译整个源文件，非常**耗时**。



> 每个函数对应一个可重定位目标模块！

我们可以通过为每个库函数创建一个独立的可重定位模块，把他们放在一个为大家都知道的目录中来解决其中的一些问题。然而，问题也是相当明显的：

1. 那你要手写多少模块啊？
2. 太多了不小心写错名字了怎么办？从头再检查一遍吧！
3. 太多了，你得写到什么时候？
4. 。。。
5. 真是一个麻烦又耗时又糟心的过程！

` gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ........`



> 静态库！

于是，为了解决这些问题，静态库诞生了！！！

我们可以结合上面的方法，既不把所有函数划分到一个模块，也不每个函数对应一个模块，而是把一些相关的函数划分到一个模块（例如 C 标准库和数学库等），然后封装成一个单独的静态库文件。而不是每个函数对应一个模块。

`gcc main.c /usr/lib/libc.a /usr/lib/libm.a .. `

你可能会问：这个静态库和前面把所有函数放在一个可重定位目标模块有什么区别吗？不就是一个叫（模块 .o)，一个叫静态库（.a）罢了！

那我可就得给你好好讲讲了：当所有函数封装在一个模块中，那我们链接的时候，就不得不链接所有库函数了。

但是！接下来好好听了！

如果说模块是函数的集合，那么静态库就是模块的集合！所以，你可能想到了，虽然我们链接到了静态库，但并不链接静态库中的所有模块，而是只链接需要用到的模块，这样既避免了类似于一个函数一个模块那样链接模块太多的问题，又避免了链接所有模块的问题。

你可能会问：这怎么实现呢？

答案是：暴力出奇迹，循环判断是否用到就好了。用不到的模块就舍弃掉。

妙不妙！再看一看静态库的定义吧。



> 在 Linux 中，静态库是以一种称为 **存档(archive)** 的特殊文件形式存放在**磁盘**中的。存档是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件由后缀（.a)标识。





### 4.2 创建静态库

[静态库和动态库创建参考](https://www.cnblogs.com/x_wukong/p/5713437.html)

> (1) 首先，我们需要源文件（.c）
>
> 这里为 mul.c 和 add.c

``` c
int mulcnt = 0;

int mul(int a, int b)
{
	mulcnt ++ ;
	return a * b;
}// mul.c
```

``` c
int addcnt = 0;

int add(int a, int b)
{
	addcnt ++ ;
	return a + b;
}// add.c
```



> (2) 然后，我们需要将源文件处理成可重定位目标文件

`gcc -c add.c mul.c`



> (3) 最后，将需要的可重定位目标文件封装到静态库中。
>
> 例如： `ar rcs mylib.a a.o b.o...`
>
> r: replace and insert
>
> c : create
>
> s: add index

`ar rcs mylib.a add.o mul.o`



> (4) 别以为就这样结束了，编写个 main 程序测试你下你的库吧！

``` c
#include <stdio.h>

int main()
{
	int x = 1, y = 2;
	int s1 = add(x, y);
	int s2 = mul(x, y);
	printf("x = %d, y = %d\nsum = %d, mul = %d\n", x, y, s1, s2);

	return 0;
}
```

```shell
gcc -c testar.c # 先编译生成可执行文件
gcc --static -o main testar.o -L. mylib.a # 与静态库链接
```

> –static 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接。所以说不加也是可以的。
>
> -Ldir 指明了链接器在那个目录下查找 mylib.a，dot就表示当前目录。







## 0x07 relocation

### 1. 重定位的任务：



重定位合并输入模块，并为每个符号分配运行时地址。

由两步组成：

1. 重定位节和符号定义：

   1. 将所有相同类型的节合并为一个节
   2. 将运行时内存地址赋给新的聚合节
   3. 赋给输入模块定义的每个符号

   完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。

2. 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为**重定位条目**的数据结构。



### 2. 重定位条目

为什么需要重定位条目？

> 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。
>
> 它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。
>
> 所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个 **“重定位条目”**，告诉链接器在将目标文件合并成可执行文件时许和修改这个引用。
>
> 代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中。



ELF 重定位条目的格式：

``` c
typedef struct {
    long offset;	// 我在那
    long type: 32;	// 怎么引用
    	smybol: 32; // 我引用了谁
    long addend;	// 我的偏移量
} Elf64_Rela;
```

> offset 是需要被修改的引用的在节内的偏移。（一般是一个地址）
>
> symbol 标识被修改引用应该指向的符号。
>
> type 告知链接器如何修改新的引用。
>
> addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。（addend的值一般是当前引用的地址距离下一条指令的偏移）（讲的标准一点就是对 rip 的修正，因为重定位所在的地址并不是下一条指令的 rip 地址）



两种最基本的重定位类型（type）：

1. R_X86_64_PC32：重定位一个使用 32 位 PC 相对地址的引用。（一个 PC 相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当 CPU 执行一条使用 PC 相对寻址的指令时，它就将在指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址， PC 值通常是**下一条**指令在内存中的地址）。

   > 简而言之，**相对**的意思就是，相对于**下一条指令**的偏移量。

   

2. R_X86_64_32：重定位一个 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址。



### 3. 重定位符号引用

>  相对引用

````assembly
call addr 
	sym.offset: R_X86_64_PC32 sym
````

首先，要清楚我们的目标：通过 addr 的**相对偏移**得到该符号的运行时地址，这个地址我们是已知的。（我们用ADDR(x)表示符号 x 的运行时地址）

当前引用的地址 + 距离下一条指令的偏移量 +  addr = 目标符号的运行时地址

addr = ADDR(sym) - （当前引用的地址 + 距离下一条指令的偏移量）

不过，距离下一条指令的偏移量通常以 sym.addend 的形式存在，于是，上式变成了：

addr = ADDR(sym) - 当前引用的地址 + sym.addend

> 我们发现，公式在经过转换后，由 “距离” 下一条指令的偏移量变成了 “加上”  sym.addend。
>
> 而偏移量肯定是一个正数（不然怎么偏移到下一条指令），所以说 sym.addend 肯定是个负数。
>
> 自己推导的，不一定对？？

而当前引用的地址 = 引用所在节的运行时地址 + 引用的偏移(sym.offset)

所以，上式最终等于如下：

addr = ADDR(sym) - （ADDR(Section) + sym.offset）+ sym.addend



----



> 绝对引用

```assembly
call addr
	sym.offset: R-X86_64_32 sym
```

addr = ADDR(sym) + sym.addend

在绝对引用中，我们依然需要加上偏移量addend，只不过 sym.addend=0。

可以发现，相较于绝对引用，相对引用只需要减去当前引用的地址即可，距离下一条指令的偏移保存在了 addend 中。

## 0x08 executable object file



典型的 ELF 可执行目标文件（EOF，段和节）：

![img](https://s1.328888.xyz/2022/09/28/spsQp.png)

ELF头还包括了程序的入口点？也就是程序的第一条指令的地址。

通过图可以发现，EOF 文件中还多了 .init 节。.init节定义了一个小函数，叫做 \_init\_，程序的初始化代码会调用它。

.text，.data，.rodata 与可重定位目标文件的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。

因为 EOF 文件是**完全链接**的（已被重定位），所以它不再需要 .rel 节。

> EOF 文件还有对其要求。这主要与虚拟内存有关







## 0x09 load EOF

我们通常在 Linux Shell 命令行输入可执行目标文件的名字 (例如prog) 来执行它:

`Linux> ./prog`

因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件。

通过调用某个驻留在内存中称为**加载器（loader）**的操作系统代码来运行它。

任何 Linux 程序都可以通过调用 **execve()** 调用加载器。

加载器将 EOF 文件的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序从磁盘复制到内存并运行的过程叫做 “加载”。

![img](https://s1.328888.xyz/2022/10/12/8jGhJ.png)

## 0x0a dynamic link shared library



### 1. 为什么引入动态库

当然是因为静态库有一些缺点了。

第一个问题，静态库不方便后续的更新和维护。

> 静态库和所有软件一样，需要定期维护和更新。
>
> 如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式的将他们的程序与更新了的库重新链接。

第二个问题，静态户仍然会造成对内存资源的极大浪费。 

> 虽然在上面 “引入静态库” 一节中我们已经说明了，静态库已经是一种比较节约内存资源的方式。
>
> 但那仅仅是在只针对一个文件的情况下，我们尽可能只引用必须用到的模块而避免引用了许多不会用到的模块造成内存浪费。
>
> 但试想一下，如果我们存在许多文件呢，几乎每个文件都会用到 printf() 函数等标准 IO 函数。在运行时，这些函数的代码会被复制到每个运行进程的文本段中（试想一下如果我们 printf() 了几百次，难道每一次调用都要复制一份 printf() 的代码吗？那也太浪费内存了！）。
>
> 特别是在一个运行上百个金层的典型系统上，这将是对稀缺的内存资源的极大浪费。
>
> **（内存的一个有趣属性就是无论系统的内存多大，他总是一种奇缺资源。磁盘空间和厨房的垃圾桶具有同样的属性）。**

于是，为了致力解决静态库的缺憾，共享库诞生了。

**共享库是一个目标模块**，在运行或加载时，**可以加载到任意的内存空间**，并和一个在内存中的程序**链接**起来。这个链接的过程就叫做 **“动态链接”**，是由一个叫做动态链接器的程序来执行的。

共享库也称为 **“共享目标”(shared object)**。在 Linux 系统中用 **.so** 后缀来标识。微软的操作系统大量的使用了共享库，它们称为 **DLL(动态链接库)**。



### 2. 共享库的工作方式

共享库是以两种不同的方式来实现 “共享”的。

首先，在任何给定的文件系统中，对于一个酷只有一个 .so 文件，所有引用该库的可执行目标文件分享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行目标文件中。（解决了静态库内存浪费的问题）

其次，再内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享（与虚拟内存有关）。

![img](https://s1.328888.xyz/2022/10/12/86kb0.png)



如何构造一个共享库：

`gcc -shared -fpic -o libname.so module1.o module2.o ....`

> -fpic 选项指示编译器生成与位置无关的代码。
>
> -shared 选项指示编译器创建一个共享的目标文件。

下面将将这个共享库链接到程序当中：

`gcc -o prog main.c ./libname.so`

根据上图(7-16)我们可以发现，可执行目标文件 prog21 在加载之后，也就是运行时可以和动态库 livvector.so 链接。基本的思路就是当创建可执行文件时，静态执行一些链接，然后在程序加载时，**动态完成链接过程**。

> by xjy：
>
>  注意上面的话并不矛盾，前一句话说程序运行时和动态库链接，下一句又说在程序加载时动态完成链接。一个是在运行时，一个是在加载时。
>
> 这可能是因为程序并不是直接全部加载到内存的（操作系统），它用到一点就加载一点，所以说，加载和运行是交叉的。

注意，再整个链接的过程当没有任何动态库的代码和数据真的被复制到可执行文件 prog21 当中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对动态库中代码和数据的引用。

### 3. 小实验

下面是一个小实验，1.c，2.c 用来构建动态库和静态库，main.c 是测试函数。

app 是链接静态库生成的可执行文件。

prog 是链接动态库生成的可执行文件。

可以发现，prog 的大小比 app 小的多（小了50多倍）。

![IMG](https://s1.328888.xyz/2022/10/12/86JI6.png)



















































